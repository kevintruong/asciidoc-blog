= UNDERSTANDING GIT & MY GIT WORKING FLOW (PART 1)
:author:Kevin Truong <kevin.truong.ds@gmail.com>
:toclevels: 4
:sectnums:
:source-highlighter: coderay
:imagesdir: ../assets/images

== GIT INTERNAL

=== Data structure

Including 3 type of structure

* Blob : hashing of the file's byte (file content in bytes array)

[.text-center]
.Blob object -git internal structure
image::git_strcuture_object-blob.964129b5.png[]
* File Tree : hashing of names and folder definition with file blob.
In another words, File Tree is hashing of filename/folder which blob belong.

[.text-center]
.Tree object - git internal structure
image::git_internal_object-tree.049e94f4.png[]

in another
* Commit: Metadata for author,commit, timestamp and message.
Then hashing the metadata we have hash of commit

[.text-center]
.Commit Object - git internal structure
image::object-commit.076d6b0d.png[]

With 3 types of data structure, Bellow is my thought about them:
When we make commit by command bellow

[source,bash]
----
git add -u # add all modified , prepare for a commit
# for example there are 2 modified files: test1.txt and test2.txt be added
git commit -m "this is my commit"
----

step 1: git will hashing content of added file `test1.txt` and `test2.txt`

[source,text]
----
for example:
test1.txt hashing : 0xabcd
test2.txt hashing : 0xcdef
----

step 2: git also create hahshing filename and its parent folder of added file.
If the hash value is not exist, git will create an entry to stored the new hash value.
step 3: git hashing the metadata of commit.
Here have some tricky:

* the hashing of commit will content the hashing of tree which changed file belong
* Hashing of blob files will be linked to tree.
Each time the file changed will create a new hash for the file. the new hash will add to the tree
* when a file not changed but move or rename , its blob hashing will remain, but it will changed the tree hashing.
At the time, the blod hashing is linked to the new hashing tree.
* We know about metadata hashing that with each commit will hashing the metadata. the hashing metadata contain hashing tree, the hashing tree contained the linked hashing blob of added files. so, from hashing commit we can found hashing blob of added files in the commit.
And also easy to comparing the change between the current with last one.
Simply by vimdiff the current blob with the previous.
Or want to get changing history of a file, git can get the history of the file simple by search in linked list of commit to find all commits which involved changing on the file.

[.text-center]
.GIT Object
image::objects-example.d8743d1c.png[]

For example:

* We want to find info of a commit.

** We know that the commit hashing contained hashing tree,author, timestamp.
from hashing tree contained hashing blob of added files and hashing tree of its parent. with each hashing blob , we can file file changes specific, with each hashing tree parent, we know the change belongs what parent.
The process will be recursived to the GIT ROOT or the the top level of tree folder has changed.
Conclusion, from commit hashing, we know all change in this commit by searching recursive all info linked to its hashing.
* We want to find all change/commit in a folder.

[source,bash]
----
cd "<your git sub folder>"
git log ./
----

** we know about git will store tree hashing of each folder.
Then the work of get all commint/change in a specific folder is simple by searching all commit which have the tree hashing of folder.

By using three different types of structure, git can provide all we need about a source project.

=== Understanding about git rebase and git merge

We already know about git internal.
Basically, there use three types of strureture and linked togeter to to make git become a perfect source version control and basic difference between `git merge` and `git rebase`.
The next thing is basic way to use git to manage your source code in a project.

.prepare for merge/rebase
image::merge-rebase01.svg[align="center"]

Short Version:

* Merge takes all the changes in one branch and merges them into another branch in one commit.
* Rebase says I want the point at which I branched to move to a new starting point So when do you use either one?

In another word (Long answer):

* Merge Let's say you have created a branch for the purpose of developing a single feature.
When you want to bring those changes back to master, you probably want merge (you don't care about maintaining all of the interim commits).

.Merge feature to master
image::merge-commit02.svg[align="center"]

* Rebase A second scenario would be if you started doing some development and then another developer made an unrelated change.
You probably want to pull and then rebase to base your changes from the current version from the repo.

.Rebase feature to master
image::rebase-commit03.svg[align="center"]

==== Git merge

==== Git rebase
//TODO must fill about git merge and git rebase, why use git rebase over git merge
== MY GIT WORKING FLOW

=== GIT FLOW BRIEF

